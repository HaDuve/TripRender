<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Route Finder</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.18.1/mapbox-gl-dev.js"></script>
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v3.18.1/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <style>
      :root {
        --panel-bg: #fff;
        --panel-text: #111;
        --input-bg: #fff;
        --input-text: #111;
        --input-border: #ccc;
        --secondary-text: #666;
        --error-color: #c00;
        --btn-bg: #3b9dd2;
        --btn-hover: #2d8bc0;
      }
      body.night-mode {
        --panel-bg: #1a1a1a;
        --panel-text: #e0e0e0;
        --input-bg: #2d2d2d;
        --input-text: #e0e0e0;
        --input-border: #444;
        --secondary-text: #999;
        --error-color: #e57373;
        --btn-bg: #4a9fd9;
        --btn-hover: #3b8fc9;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, sans-serif;
      }
      #panelWrapper {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 10;
        display: flex;
        align-items: flex-start;
      }
      #panelWrapper #panelToggle {
        width: 44px;
        min-width: 44px;
        min-height: 48px;
        padding: 0;
        margin: 0;
        background: var(--panel-bg);
        color: var(--panel-text);
        border: none;
        border-right: 1px solid var(--input-border);
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 12px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      #panelWrapper #panelToggle svg {
        width: 22px;
        height: 22px;
        fill: currentColor;
      }
      #panelWrapper #panelToggle:hover {
        background: var(--input-bg);
      }
      #panelWrapper #input {
        width: auto;
        min-width: 560px;
        max-width: 90vw;
        max-height: 100vh;
        overflow-x: hidden;
        overflow-y: auto;
        background: var(--panel-bg);
        color: var(--panel-text);
        padding: 12px;
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
        transform: translateX(calc(-100% - 44px));
        transition: transform 0.2s ease;
      }
      .panel-columns {
        display: flex;
        gap: 20px;
        min-height: 75vh;
        align-items: flex-start;
      }
      .panel-col {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 0;
        flex: 1;
      }
      .panel-col-route #addStopBtn {
        width: 100%;
        max-width: 600px;
      }
      .panel-col-actions button {
        width: 100%;
        max-width: 220px;
      }
      #panelWrapper.panel-open #input {
        transform: translateX(0);
      }
      #panelWrapper:not(.panel-open) #input {
        pointer-events: none;
      }
      #panelWrapper:not(.panel-open) {
        pointer-events: none;
      }
      #panelWrapper:not(.panel-open) #panelToggle {
        pointer-events: auto;
      }
      #animationStrip {
        display: none;
        position: fixed;
        top: 48px;
        left: 0;
        z-index: 10;
        flex-direction: column;
        gap: 4px;
        padding: 0;
        margin: 0;
      }
      #animationStrip.visible {
        display: flex;
      }
      #animationStrip button {
        width: 44px;
        min-width: 44px;
        height: 44px;
        min-height: 44px;
        padding: 0;
        margin: 0;
        background: var(--btn-bg);
        color: white;
        border: none;
        border-right: 1px solid var(--input-border);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #animationStrip button:first-of-type {
        border-radius: 0;
        box-shadow: 2px 0 12px rgba(0, 0, 0, 0.2);
      }
      #animationStrip button:last-of-type {
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 12px rgba(0, 0, 0, 0.2);
      }
      #animationStrip button:hover {
        background: var(--btn-hover);
      }
      #animationStrip button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #animationStrip button svg {
        width: 22px;
        height: 22px;
        fill: currentColor;
      }
      #map {
        width: 100vw;
        height: 100vh;
      }
      input,
      button {
        padding: 8px 12px;
        margin: 4px 0;
        width: 260px;
        font-size: 14px;
        background: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: 6px;
      }
      button {
        cursor: pointer;
        background: var(--btn-bg);
        color: white;
        border: none;
        border-radius: 6px;
        font-weight: 500;
      }
      button:hover {
        background: var(--btn-hover);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .draw-route-wrap {
        position: relative;
        width: 100%;
        max-width: 220px;
      }
      .draw-route-wrap .draw-route-overlay {
        display: none;
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 6px;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }
      .draw-route-wrap.loading .draw-route-overlay {
        display: flex;
      }
      .draw-route-overlay .spinner {
        width: 24px;
        height: 24px;
        border: 3px solid var(--input-border);
        border-top-color: var(--btn-bg);
        border-radius: 50%;
        animation: draw-route-spin 0.8s linear infinite;
      }
      @keyframes draw-route-spin {
        to { transform: rotate(360deg); }
      }
      #error {
        color: var(--error-color);
        font-size: 13px;
        margin-top: 6px;
        max-width: 600px;
      }
      .control-toggle {
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        margin: 8px 0 4px;
        user-select: none;
        color: var(--panel-text);
      }
      .control-toggle::before {
        content: "▸ ";
        display: inline-block;
        transition: transform 0.2s;
      }
      .control-toggle.expanded::before {
        transform: rotate(90deg);
      }
      #animationControls {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.2s ease-out;
      }
      #animationControls.expanded {
        max-height: 360px;
      }
      #exportStatus {
        font-size: 12px;
        color: var(--secondary-text);
        margin-top: 4px;
      }
      .control-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
        font-size: 13px;
      }
      .control-row input[type="checkbox"] {
        width: auto;
        margin: 0;
        accent-color: var(--btn-bg);
      }
      .control-row input[type="number"] {
        width: 80px;
        margin: 0 0 0 auto;
      }
      .control-row label {
        flex: 1;
        cursor: pointer;
        color: var(--panel-text);
      }
      .control-row select {
        padding: 6px 8px;
        font-size: 13px;
        background: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: 6px;
      }
      #waypoints {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      #waypoints input {
        width: 100%;
        max-width: 600px;
      }
      .leg-control {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 2px 0;
        font-size: 12px;
      }
      .leg-control label {
        flex: 0 0 auto;
        color: var(--secondary-text);
        margin: 0;
      }
      .leg-control select.leg-mode {
        width: auto;
        min-width: 90px;
        margin: 0;
        padding: 4px 8px;
        font-size: 12px;
      }
      .leg-control .leg-duration-wrap {
        display: none;
        align-items: center;
        gap: 6px;
        margin-left: 8px;
      }
      .leg-control .leg-duration-wrap label {
        flex: 0 0 auto;
        color: var(--secondary-text);
        margin: 0;
      }
      .leg-control .leg-duration-wrap .leg-duration-input {
        width: 70px;
        min-width: 70px;
        margin: 0;
        padding: 4px 6px;
        font-size: 12px;
      }
      body.manual-leg-durations .leg-control .leg-duration-wrap {
        display: flex;
      }
      .waypoint-row {
        display: flex;
        align-items: center;
        gap: 0;
        margin: 4px 0;
        max-width: 628px;
      }
      .waypoint-row input {
        width: auto;
        flex: 1;
        min-width: 0;
        max-width: 600px;
        margin: 0;
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
      }
      .waypoint-row .leg-delete-btn {
        width: 28px;
        min-width: 28px;
        height: 34px;
        padding: 0;
        font-size: 16px;
        line-height: 1;
        border-radius: 0 6px 6px 0;
        border-left: none;
      }
      #addStopBtn {
        margin-top: 6px;
        background: transparent;
        color: var(--panel-text);
        border: 1px solid var(--input-border);
      }
      #addStopBtn:hover:not(:disabled) {
        background: var(--input-bg);
      }
      #waypoint-suggestions {
        display: none;
        position: fixed;
        z-index: 100;
        max-height: 220px;
        overflow-y: auto;
        background: var(--panel-bg);
        color: var(--panel-text);
        border: 1px solid var(--input-border);
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      #waypoint-suggestions.visible {
        display: block;
      }
      #waypoint-suggestions .waypoint-suggestion-item {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 14px;
        border: none;
        background: none;
        color: inherit;
        width: 100%;
        text-align: left;
      }
      #waypoint-suggestions .waypoint-suggestion-item:hover {
        background: var(--input-bg);
      }
    </style>
  </head>
  <body>
    <div id="panelWrapper">
      <button
        type="button"
        id="panelToggle"
        onclick="togglePanel()"
        aria-label="Toggle panel"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z" />
        </svg>
      </button>
      <div id="input">
        <div class="panel-columns">
          <div class="panel-col panel-col-route">
            <div id="waypoints">
              <div class="waypoint-row">
                <input type="text" placeholder="Start" value="New York, NY" />
                <button type="button" class="leg-delete-btn" aria-label="Clear or remove" onclick="deleteOrClearWaypoint(this)">×</button>
              </div>
              <div class="leg-control control-row">
                <label>To next:</label>
                <select class="leg-mode">
                  <option value="walk">Walk</option>
                  <option value="drive" selected>Drive</option>
                  <option value="fly">Fly</option>
                </select>
                <span class="leg-duration-wrap">
                  <label>Duration (s)</label>
                  <input type="number" class="leg-duration-input" min="0.1" step="0.1" />
                </span>
              </div>
              <div class="waypoint-row">
                <input type="text" placeholder="End" value="Boston, MA" />
                <button type="button" class="leg-delete-btn" aria-label="Clear or remove" onclick="deleteOrClearWaypoint(this)">×</button>
              </div>
            </div>
            <div id="waypoint-suggestions" role="listbox" aria-hidden="true"></div>
            <button id="addStopBtn" type="button" onclick="addWaypoint()">
              Add stop
            </button>
            <div id="error"></div>
          </div>
          <div class="panel-col panel-col-actions">
            <div class="draw-route-wrap" id="drawRouteWrap">
              <button id="drawRouteBtn" onclick="getRoute()">Draw Route</button>
              <div class="draw-route-overlay" aria-hidden="true">
                <span class="spinner"></span>
              </div>
            </div>
            <button id="animateBtn" onclick="animateRoute()" disabled>
              Animate Route
            </button>
            <button id="exportBtn" onclick="exportVideo()" disabled>
              Export video
            </button>
            <div class="control-row">
              <input type="checkbox" id="nightMode" />
              <label for="nightMode">Night mode</label>
            </div>
            <div
              class="control-toggle"
              id="animationToggle"
              onclick="toggleAnimationControls()"
            >
              Animation controls
            </div>
            <div id="animationControls">
          <div class="control-row">
            <input type="checkbox" id="lineGradient" checked />
            <label for="lineGradient">Line gradient</label>
          </div>
          <div class="control-row">
            <input type="checkbox" id="cameraFollow" checked />
            <label for="cameraFollow">Camera follow</label>
          </div>
          <div class="control-row">
            <input type="checkbox" id="bearingChange" />
            <label for="bearingChange">Bearing change</label>
          </div>
          <div class="control-row">
            <input type="checkbox" id="editDurationsManually" />
            <label for="editDurationsManually">Edit durations manually</label>
          </div>
          <div class="control-row">
            <label for="duration">Duration (s)</label>
            <input
              type="number"
              id="duration"
              value="2"
              min="0.1"
              step="0.1"
            />
          </div>
          <div class="control-row">
            <label for="maxTimePerStep">Max time per step (s)</label>
            <input
              type="number"
              id="maxTimePerStep"
              value="2"
              min="0.1"
              step="0.1"
            />
          </div>
          <div class="control-row">
            <label for="speedup">Max speedup (1–4)</label>
            <input
              type="number"
              id="speedup"
              value="4"
              min="1"
              max="4"
              step="1"
            />
          </div>
          <div class="control-row">
            <label for="startBearing">Bearing (°)</label>
            <input
              type="number"
              id="startBearing"
              value="0"
              min="-180"
              max="180"
            />
          </div>
          <div class="control-row">
            <label for="startAltitude">Altitude (m)</label>
            <input
              type="number"
              id="startAltitude"
              value="500000"
              min="100"
              step="100"
            />
          </div>
          <div class="control-row">
            <label for="pitch">Pitch (°)</label>
            <input type="number" id="pitch" value="20" min="0" max="85" />
          </div>
          <div class="control-row">
            <label for="exportSize">Export size</label>
            <select
              id="exportSize"
              style="min-width: 140px; margin: 0 0 0 auto; padding: 6px"
            >
              <optgroup label="Portrait">
                <option value="1080x1920">9:16 (Reels/Shorts)</option>
                <option value="1080x1350">4:5 (IG portrait)</option>
              </optgroup>
              <optgroup label="Landscape">
                <option value="1920x1080">16:9 (1080p)</option>
                <option value="1280x720">16:9 (720p)</option>
              </optgroup>
              <optgroup label="Square">
                <option value="1080x1080">1:1</option>
              </optgroup>
            </select>
          </div>
            </div>
            <div id="exportStatus"></div>
          </div>
        </div>
      </div>
    </div>
    <div id="animationStrip">
      <button type="button" id="animationStripPause" onclick="animateRoute()" aria-label="Pause">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>
      </button>
      <button type="button" id="stopBtn" onclick="stopAnimation()" aria-label="Stop">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6h12v12H6z"/></svg>
      </button>
    </div>
    <div id="map"></div>

    <script>
      mapboxgl.accessToken = "__MAPBOX_TOKEN__";

      const map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/mapbox/standard",
        center: [-74.5, 40],
        zoom: 4,
      });

      const nightModeCheckbox = document.getElementById("nightMode");

      function applyNightMode(checked) {
        document.body.classList.toggle("night-mode", checked);
        const setMapPreset = () =>
          map.setConfigProperty(
            "basemap",
            "lightPreset",
            checked ? "night" : "day",
          );
        if (map.isStyleLoaded()) {
          setMapPreset();
        } else {
          map.once("load", setMapPreset);
        }
        try {
          localStorage.setItem("nightMode", checked ? "1" : "0");
        } catch (_) {}
      }

      const savedNightMode = localStorage.getItem("nightMode") === "1";
      nightModeCheckbox.checked = savedNightMode;
      applyNightMode(savedNightMode);

      nightModeCheckbox.addEventListener("change", (e) => {
        applyNightMode(e.target.checked);
      });

      let currentRoute = null;
      let animationState = "idle"; // "idle" | "playing" | "paused"
      let animationControls = { stopRequested: false, pauseRequested: false };
      let exportInProgress = false;

      const ICON_PAUSE = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>';
      const ICON_PLAY = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"/></svg>';

      function updateAnimationUI() {
        const animateBtn = document.getElementById("animateBtn");
        const strip = document.getElementById("animationStrip");
        const stripPauseBtn = document.getElementById("animationStripPause");
        const stopBtn = document.getElementById("stopBtn");
        strip.classList.toggle("visible", animationState === "playing" || animationState === "paused");
        if (stripPauseBtn) {
          const isPlaying = animationState === "playing";
          stripPauseBtn.innerHTML = isPlaying ? ICON_PAUSE : ICON_PLAY;
          stripPauseBtn.setAttribute("aria-label", isPlaying ? "Pause" : "Continue");
        }
        if (exportInProgress || !currentRoute) {
          animateBtn.disabled = true;
          if (stopBtn) stopBtn.disabled = true;
          animateBtn.textContent = "Animate Route";
          return;
        }
        if (animationState === "idle") {
          animateBtn.disabled = false;
          animateBtn.textContent = "Animate Route";
          if (stopBtn) stopBtn.disabled = true;
        } else {
          animateBtn.disabled = false;
          animateBtn.textContent = animationState === "playing" ? "Pause" : "Continue";
          if (stopBtn) stopBtn.disabled = false;
        }
      }

      function lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
      }

      // --- Mercator & camera math (see Mapbox blog: building-cinematic-route-animations-with-mapboxgl) ---
      // Web Mercator (EPSG:3857): x = R*lng*π/180, y = R*ln(tan(π/4 + lat*π/360)). R ≈ 20037508.34 m.
      function mercatorDistanceMeters(a, b) {
        const toM = (lng, lat) => {
          const x = (lng * 20037508.34) / 180;
          const y =
            Math.log(Math.tan((90 + lat) * (Math.PI / 360))) *
            (20037508.34 / Math.PI);
          return { x, y };
        };
        const p = toM(a[0], a[1]);
        const q = toM(b[0], b[1]);
        return Math.hypot(q.x - p.x, q.y - p.y);
      }

      // Progress 0..1 along route using Mercator segment lengths (matches Mapbox line-progress).
      function pointAlongRouteByProgress(coords, progress) {
        if (!coords.length) return coords[0];
        if (coords.length === 1 || progress <= 0) return coords[0];
        let total = 0;
        const segLengths = [];
        for (let i = 1; i < coords.length; i++) {
          const d = mercatorDistanceMeters(coords[i - 1], coords[i]);
          segLengths.push(d);
          total += d;
        }
        if (total <= 0 || progress >= 1) return coords[coords.length - 1];
        const target = progress * total;
        let acc = 0;
        for (let i = 0; i < segLengths.length; i++) {
          if (acc + segLengths[i] >= target) {
            const t = (target - acc) / segLengths[i];
            return [
              lerp(coords[i][0], coords[i + 1][0], t),
              lerp(coords[i][1], coords[i + 1][1], t),
            ];
          }
          acc += segLengths[i];
        }
        return coords[coords.length - 1];
      }

      function pointAlongRoute(coords, distanceKm) {
        if (!coords.length) return coords[0];
        if (coords.length === 1 || distanceKm <= 0) return coords[0];
        const totalKm = turf.length(turf.lineString(coords), {
          units: "kilometers",
        });
        if (distanceKm >= totalKm) return coords[coords.length - 1];
        let acc = 0;
        for (let i = 1; i < coords.length; i++) {
          const seg = [coords[i - 1], coords[i]];
          const segKm = turf.length(turf.lineString(seg), {
            units: "kilometers",
          });
          if (acc + segKm >= distanceKm) {
            const t = (distanceKm - acc) / segKm;
            return [
              lerp(coords[i - 1][0], coords[i][0], t),
              lerp(coords[i - 1][1], coords[i][1], t),
            ];
          }
          acc += segKm;
        }
        return coords[coords.length - 1];
      }

      let _previousCameraPosition = null;
      let _previousCameraTarget = null;

      // More south (lower lat) → lower pitch (look more down). Base pitch is at equator; scales with lat.
      function pitchForLatitude(basePitch, lat) {
        const PITCH_PER_DEG_LAT = 0.3;
        const p = basePitch + lat * PITCH_PER_DEG_LAT;
        return Math.max(0, Math.min(85, p));
      }

      // Camera position from target on ground: same idea as Mapbox blog (bearing/pitch/altitude → offset).
      // Radians: 57.2958 ≈ 180/π. Longitude: meters per degree = 111e3*cos(lat) ≈ 70e3 at mid-lat; we use cos(lat).
      // Latitude: ~111 km/degree. offsetScale=0 → camera directly above target.
      function computeCameraPosition(
        pitch,
        bearing,
        targetPosition,
        altitude,
        smooth = false,
        offsetScale = 1,
      ) {
        const rad = Math.PI / 180;
        const bearingRad = bearing * rad;
        const pitchRad = (90 - pitch) * rad;
        const latRad = targetPosition.lat * rad;
        const metersPerDegLng = 111000 * Math.max(0.01, Math.cos(latRad));
        const lngDiff =
          (offsetScale *
            ((altitude / Math.tan(pitchRad)) * Math.sin(-bearingRad))) /
          metersPerDegLng;
        const latDiff =
          (offsetScale *
            ((altitude / Math.tan(pitchRad)) * Math.cos(-bearingRad))) /
          111000;
        const newCameraPosition = {
          lng: targetPosition.lng + lngDiff,
          lat: targetPosition.lat - latDiff,
        };
        if (smooth && _previousCameraPosition) {
          const SMOOTH_FACTOR = 0.95;
          newCameraPosition.lng = lerp(
            newCameraPosition.lng,
            _previousCameraPosition.lng,
            SMOOTH_FACTOR,
          );
          newCameraPosition.lat = lerp(
            newCameraPosition.lat,
            _previousCameraPosition.lat,
            SMOOTH_FACTOR,
          );
        }
        _previousCameraPosition = newCameraPosition;
        return newCameraPosition;
      }

      function setPanelOpen(open) {
        const wrapper = document.getElementById("panelWrapper");
        wrapper.classList.toggle("panel-open", open);
        try {
          localStorage.setItem("panelOpen", open ? "1" : "0");
        } catch (_) {}
      }

      (function initPanelState() {
        try {
          const saved = localStorage.getItem("panelOpen");
          const open = saved !== null ? saved === "1" : true;
          document
            .getElementById("panelWrapper")
            .classList.toggle("panel-open", open);
        } catch (_) {}
      })();

      function togglePanel() {
        const wrapper = document.getElementById("panelWrapper");
        setPanelOpen(!wrapper.classList.contains("panel-open"));
      }

      function toggleAnimationControls() {
        const toggle = document.getElementById("animationToggle");
        const panel = document.getElementById("animationControls");
        toggle.classList.toggle("expanded");
        panel.classList.toggle("expanded");
      }

      const MIN_LEG_DURATION_S = 0.1;
      const MAX_LEG_DURATION_S = 60;
      const MIN_LEG_DURATION_MS = 100;
      const MAX_LEG_DURATION_MS = 60000;

      function syncDurationFromLegInputs() {
        const inputs = document.querySelectorAll("#waypoints .leg-duration-input");
        if (!inputs.length) return;
        const values = Array.from(inputs).map((el) => {
          let v = Number(el.value) || MIN_LEG_DURATION_S;
          v = Math.max(MIN_LEG_DURATION_S, Math.min(MAX_LEG_DURATION_S, v));
          el.value = v;
          return v;
        });
        const sum = values.reduce((a, b) => a + b, 0);
        const durationEl = document.getElementById("duration");
        const maxTimeEl = document.getElementById("maxTimePerStep");
        if (durationEl) durationEl.value = Math.round(sum * 10) / 10;
        if (maxTimeEl) maxTimeEl.value = Math.round(Math.max(...values) * 10) / 10;
      }

      function syncManualLegDurationsFromRoute() {
        const inputs = document.querySelectorAll("#waypoints .leg-duration-input");
        const numLegs = inputs.length;
        if (!numLegs) return;
        if (currentRoute?.properties?.legLengths) {
          const legLengths = currentRoute.properties.legLengths;
          const maxTimePerStepMs =
            (Number(document.getElementById("maxTimePerStep")?.value) || 2) * 1000;
          const speedup =
            Number(document.getElementById("speedup")?.value) || 4;
          const durs = getLegDurations(
            legLengths,
            maxTimePerStepMs,
            speedup,
          );
          if (durs && durs.length === numLegs) {
            inputs.forEach((el, i) => {
              el.value = Math.round((durs[i] / 1000) * 10) / 10;
            });
          }
        } else {
          const totalS =
            Number(document.getElementById("duration")?.value) || 2;
          const perLeg = Math.max(
            MIN_LEG_DURATION_S,
            Math.round((totalS / numLegs) * 10) / 10,
          );
          inputs.forEach((el) => {
            el.value = perLeg;
          });
        }
        syncDurationFromLegInputs();
      }

      (function initEditDurationsManually() {
        const cb = document.getElementById("editDurationsManually");
        if (!cb) return;
        cb.addEventListener("change", () => {
          document.body.classList.toggle("manual-leg-durations", cb.checked);
          if (cb.checked) syncManualLegDurationsFromRoute();
        });
        document.getElementById("waypoints").addEventListener("input", (e) => {
          if (!e.target.classList.contains("leg-duration-input")) return;
          syncDurationFromLegInputs();
        });
        document.getElementById("waypoints").addEventListener("change", (e) => {
          if (!e.target.classList.contains("leg-duration-input")) return;
          syncDurationFromLegInputs();
        });
      })();

      function getManualLegDurationsForAnimation(expectedLength) {
        if (!document.getElementById("editDurationsManually")?.checked)
          return null;
        const inputs = document.querySelectorAll(
          "#waypoints .leg-duration-input",
        );
        if (inputs.length !== expectedLength) return null;
        const values = Array.from(inputs).map((el) => {
          const v = (Number(el.value) || MIN_LEG_DURATION_S) * 1000;
          return Math.max(MIN_LEG_DURATION_MS, Math.min(MAX_LEG_DURATION_MS, v));
        });
        return values;
      }

      function getLegDurations(legLengths, maxTimePerStep, speedup) {
        if (!legLengths?.length) return null;
        const safeSpeedup = Math.max(1, Number(speedup) || 1);
        const safeMax = Math.max(0, Number(maxTimePerStep) || 2000);
        const maxLegLength = Math.max(...legLengths, 0);
        if (maxLegLength === 0)
          return legLengths.map(() => safeMax);
        const minDur = safeMax / safeSpeedup;
        const range = safeMax - minDur;
        return legLengths.map(
          (len) => minDur + range * (len / maxLegLength),
        );
      }

      function timeToProgress(
        elapsedMs,
        legEndProgress,
        legLengths,
        maxTimePerStep,
        speedup,
        overrideLegDurations,
      ) {
        const numLegs = legEndProgress.length;
        if (numLegs === 0) return 1;
        const safeMax = Math.max(0, Number(maxTimePerStep) || 2000);
        const legDurations =
          overrideLegDurations &&
          overrideLegDurations.length === numLegs &&
          overrideLegDurations.every(
            (d) => Number.isFinite(d) && d > 0,
          )
            ? overrideLegDurations
            : getLegDurations(legLengths, maxTimePerStep, speedup);
        const totalDuration = legDurations
          ? legDurations.reduce((a, b) => a + b, 0)
          : numLegs * safeMax;
        if (
          !Number.isFinite(totalDuration) ||
          totalDuration <= 0 ||
          elapsedMs >= totalDuration
        )
          return 1;
        const durs = legDurations ?? legEndProgress.map(() => safeMax);
        let cum = 0;
        let legIndex = 0;
        for (let i = 0; i < numLegs; i++) {
          if (elapsedMs < cum + durs[i]) {
            legIndex = i;
            break;
          }
          cum += durs[i];
          legIndex = i;
        }
        const legDur = durs[legIndex];
        const tInLeg =
          legDur <= 0 || !Number.isFinite(legDur) ? 1 : (elapsedMs - cum) / legDur;
        const progressStart =
          legIndex === 0 ? 0 : legEndProgress[legIndex - 1];
        const progressEnd = legEndProgress[legIndex];
        return progressStart + tInLeg * (progressEnd - progressStart);
      }

      function updateAnimationFrame(
        map,
        path,
        pathDistance,
        animationPhase,
        opts,
      ) {
        const {
          startBearing,
          startAltitude,
          pitch,
          lineGradient,
          cameraFollow,
          bearingChange,
        } = opts;
        if (lineGradient) {
          map.setPaintProperty("route", "line-gradient", [
            "step",
            ["line-progress"],
            "#3b9dd2",
            animationPhase,
            "rgba(0,0,0,0)",
          ]);
        }
        if (cameraFollow) {
          const coords = path.geometry?.coordinates ?? path.coordinates;
          // Use Mercator-based progress so camera aligns with line-progress (2D render).
          const [lng, lat] = coords
            ? pointAlongRouteByProgress(coords, animationPhase)
            : turf.along(path, pathDistance * animationPhase, {
                units: "kilometers",
              }).geometry.coordinates;
          let targetPosition = { lng, lat };
          // Optional lag: smooth camera target so it doesn't run ahead of the blue line.
          const CAMERA_LAG = 0.22;
          if (_previousCameraTarget) {
            targetPosition = {
              lng: lerp(_previousCameraTarget.lng, targetPosition.lng, CAMERA_LAG),
              lat: lerp(_previousCameraTarget.lat, targetPosition.lat, CAMERA_LAG),
            };
          }
          _previousCameraTarget = targetPosition;
          const effectivePitch = pitchForLatitude(pitch, targetPosition.lat);
          // offsetScale=1 so camera is placed behind the target; view ray then hits the progress point.
          const cameraPos = computeCameraPosition(
            effectivePitch,
            startBearing,
            targetPosition,
            startAltitude,
            false,
            1,
          );
          const camera = map.getFreeCameraOptions();
          camera.position = mapboxgl.MercatorCoordinate.fromLngLat(
            [cameraPos.lng, cameraPos.lat],
            startAltitude,
          );
          camera.setPitchBearing(effectivePitch, startBearing);
          map.setFreeCameraOptions(camera);
        }
      }

      function stopAnimation() {
        animationControls.stopRequested = true;
      }

      function animatePath({
        map,
        path,
        maxTimePerStep,
        speedup,
        manualLegDurations,
        startBearing,
        startAltitude,
        pitch,
        lineGradient,
        cameraFollow,
        bearingChange,
        exportMode = false,
        onProgress,
        onRender,
        controls,
      }) {
        _previousCameraPosition = null;
        _previousCameraTarget = null;
        const line = path.geometry
          ? turf.lineString(path.geometry.coordinates.slice())
          : path;
        const pathDistance = turf.length(line, { units: "kilometers" });
        const legEndProgress = path.properties?.legEndProgress ?? [1];
        const legLengths = path.properties?.legLengths ?? null;
        const numLegs = legEndProgress.length;
        const useManual =
          manualLegDurations &&
          manualLegDurations.length === numLegs &&
          manualLegDurations.every(
            (d) => Number.isFinite(d) && d >= MIN_LEG_DURATION_MS,
          );
        const legDurations = useManual
          ? manualLegDurations
          : getLegDurations(legLengths, maxTimePerStep, speedup);
        const duration = legDurations
          ? legDurations.reduce((a, b) => a + b, 0)
          : numLegs * maxTimePerStep;
        const overrideDurs = useManual ? legDurations : null;
        const opts = {
          startBearing,
          startAltitude,
          pitch,
          lineGradient,
          cameraFollow,
          bearingChange,
        };

        if (exportMode) {
          return new Promise((resolve) => {
            let now =
              typeof performance !== "undefined" ? performance.now() : 0;
            const startTime = now;
            const maxElapsed = Math.max(duration * 1.5, duration + 5000);
            if (typeof mapboxgl.setNow === "function") mapboxgl.setNow(now);

            const done = () => {
              map.removeLayer("_export-driver");
              map.off("render", captureFrame);
              if (typeof mapboxgl.restoreNow === "function")
                mapboxgl.restoreNow();
              resolve();
            };

            const captureFrame = () => {
              const elapsed = now - startTime;
              const animationPhase = timeToProgress(
                elapsed,
                legEndProgress,
                legLengths,
                maxTimePerStep,
                speedup,
                overrideDurs,
              );
              if (onProgress) onProgress(Math.min(1, animationPhase));
              if (onRender) onRender();
            };

            const driverLayer = {
              id: "_export-driver",
              type: "custom",
              onAdd() {},
              render(gl, matrix) {
                now += 1000 / 60;
                if (typeof mapboxgl.setNow === "function") mapboxgl.setNow(now);
                const elapsed = now - startTime;
                if (elapsed >= duration || elapsed >= maxElapsed) {
                  done();
                  return;
                }
                const animationPhase = timeToProgress(
                  elapsed,
                  legEndProgress,
                  legLengths,
                  maxTimePerStep,
                  speedup,
                  overrideDurs,
                );
                if (animationPhase >= 0.9999) {
                  done();
                  return;
                }
                updateAnimationFrame(
                  map,
                  line,
                  pathDistance,
                  Math.min(animationPhase, 1),
                  opts,
                );
                map.triggerRepaint();
              },
            };

            map.on("render", captureFrame);
            updateAnimationFrame(map, line, pathDistance, 0, opts);
            map.addLayer(driverLayer);
          });
        }

        return new Promise((resolve) => {
          let startTime;
          let pausedElapsed = null;
          const getStop = () => controls?.stopRequested === true;
          const getPause = () => controls?.pauseRequested === true;

          const frame = (currentTime) => {
            if (getStop()) {
              _previousCameraPosition = null;
              _previousCameraTarget = null;
              updateAnimationFrame(map, line, pathDistance, 0, opts);
              resolve();
              return;
            }
            if (getPause()) {
              if (pausedElapsed === null && startTime != null)
                pausedElapsed = currentTime - startTime;
              const phase = timeToProgress(
                pausedElapsed ?? 0,
                legEndProgress,
                legLengths,
                maxTimePerStep,
                speedup,
                overrideDurs,
              );
              updateAnimationFrame(map, line, pathDistance, phase, opts);
              requestAnimationFrame(frame);
              return;
            }
            if (pausedElapsed !== null) {
              startTime = currentTime - pausedElapsed;
              pausedElapsed = null;
            }
            if (!startTime) startTime = currentTime;
            const elapsed = currentTime - startTime;
            const animationPhase = timeToProgress(
              elapsed,
              legEndProgress,
              legLengths,
              maxTimePerStep,
              speedup,
              overrideDurs,
            );

            if (animationPhase >= 1) {
              resolve();
              return;
            }

            updateAnimationFrame(map, line, pathDistance, animationPhase, opts);
            requestAnimationFrame(frame);
          };

          requestAnimationFrame(frame);
        });
      }

      const MAX_WAYPOINTS = 24;

      function getWaypointInputs() {
        return document.querySelectorAll("#waypoints .waypoint-row input");
      }

      function getLegModes() {
        return Array.from(
          document.querySelectorAll("#waypoints .leg-mode"),
        ).map((el) =>
          el.value === "walk" || el.value === "fly" ? el.value : "drive",
        );
      }

      function setLegMode(legIndex, mode) {
        const selects = document.querySelectorAll("#waypoints .leg-mode");
        const el = selects[legIndex];
        if (el) el.value = mode;
      }

      function updateAddStopState() {
        const btn = document.getElementById("addStopBtn");
        btn.disabled = getWaypointInputs().length >= MAX_WAYPOINTS;
      }

      function deleteOrClearWaypoint(btn) {
        const row = btn.closest(".waypoint-row");
        if (!row) return;
        const input = row.querySelector("input");
        if (!input) return;
        const numWaypoints = getWaypointInputs().length;
        if (numWaypoints <= 2) {
          input.value = "";
          return;
        }
        const legToRemove = row.previousElementSibling?.classList?.contains("leg-control")
          ? row.previousElementSibling
          : row.nextElementSibling;
        if (legToRemove?.classList?.contains("leg-control")) legToRemove.remove();
        row.remove();
        updateAddStopState();
        document.getElementById("waypoints").dispatchEvent(new CustomEvent("waypoint-row-removed"));
      }

      function createLegControl() {
        const div = document.createElement("div");
        div.className = "leg-control control-row";
        const label = document.createElement("label");
        label.textContent = "To next:";
        const select = document.createElement("select");
        select.className = "leg-mode";
        ["walk", "drive", "fly"].forEach((val) => {
          const opt = document.createElement("option");
          opt.value = val;
          opt.textContent = val.charAt(0).toUpperCase() + val.slice(1);
          if (val === "drive") opt.selected = true;
          select.appendChild(opt);
        });
        const wrap = document.createElement("span");
        wrap.className = "leg-duration-wrap";
        const durLabel = document.createElement("label");
        durLabel.textContent = "Duration (s)";
        const durInput = document.createElement("input");
        durInput.type = "number";
        durInput.className = "leg-duration-input";
        durInput.min = 0.1;
        durInput.step = 0.1;
        durInput.value =
          document.getElementById("maxTimePerStep")?.value || 2;
        wrap.appendChild(durLabel);
        wrap.appendChild(durInput);
        div.appendChild(label);
        div.appendChild(select);
        div.appendChild(wrap);
        return div;
      }

      function createWaypointRow(placeholder) {
        const row = document.createElement("div");
        row.className = "waypoint-row";
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = placeholder;
        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "leg-delete-btn";
        deleteBtn.setAttribute("aria-label", "Clear or remove");
        deleteBtn.textContent = "×";
        deleteBtn.onclick = function () { deleteOrClearWaypoint(this); };
        row.appendChild(input);
        row.appendChild(deleteBtn);
        return row;
      }

      function addWaypoint() {
        if (getWaypointInputs().length >= MAX_WAYPOINTS) return;
        const container = document.getElementById("waypoints");
        container.appendChild(createLegControl());
        container.appendChild(createWaypointRow("Stop"));
        updateAddStopState();
        container.querySelector(".waypoint-row:last-of-type input").focus();
      }

      (function initWaypointSuggestions() {
        const SUGGEST_DEBOUNCE_MS = 250;
        const MIN_QUERY_LENGTH = 2;
        const SUGGEST_LIMIT = 5;

        const dropdown = document.getElementById("waypoint-suggestions");
        let suggestTimeout = null;
        let activeSuggestInput = null;

        function isInputValid(el) {
          return el && document.contains(el);
        }

        function hideSuggestions() {
          if (suggestTimeout) {
            clearTimeout(suggestTimeout);
            suggestTimeout = null;
          }
          dropdown.classList.remove("visible");
          dropdown.setAttribute("aria-hidden", "true");
          dropdown.innerHTML = "";
          activeSuggestInput = null;
        }

        function positionDropdownUnderInput(inputEl) {
          const rect = inputEl.getBoundingClientRect();
          const panelEl = document.getElementById("input");
          const panelRect = panelEl ? panelEl.getBoundingClientRect() : { top: 0, left: 0 };
          dropdown.style.top = (rect.bottom - panelRect.top) + "px";
          dropdown.style.left = (rect.left - panelRect.left) + "px";
          dropdown.style.width = Math.max(rect.width, 260) + "px";
        }

        function showSuggestions(inputEl, features) {
          if (!inputEl || !features.length) {
            hideSuggestions();
            return;
          }
          if (!isInputValid(inputEl)) {
            hideSuggestions();
            return;
          }
          activeSuggestInput = inputEl;
          positionDropdownUnderInput(inputEl);
          dropdown.innerHTML = "";
          features.forEach((f) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "waypoint-suggestion-item";
            btn.textContent = f.place_name;
            btn.setAttribute("data-place-name", f.place_name);
            dropdown.appendChild(btn);
          });
          dropdown.classList.add("visible");
          dropdown.setAttribute("aria-hidden", "false");
        }

        function fetchSuggestions(query) {
          const url =
            "https://api.mapbox.com/geocoding/v5/mapbox.places/" +
            encodeURIComponent(query) +
            ".json?access_token=" +
            mapboxgl.accessToken +
            "&limit=" +
            SUGGEST_LIMIT;
          return fetch(url).then((r) => r.json());
        }

        function runSuggest(inputEl) {
          const q = inputEl.value.trim();
          if (q.length < MIN_QUERY_LENGTH) {
            hideSuggestions();
            return;
          }
          fetchSuggestions(q).then((data) => {
            const features = data.features || [];
            if (!isInputValid(activeSuggestInput)) {
              activeSuggestInput = null;
              hideSuggestions();
              return;
            }
            if (activeSuggestInput === inputEl) {
              showSuggestions(inputEl, features);
            }
          }).catch(() => {
            if (!isInputValid(activeSuggestInput)) {
              activeSuggestInput = null;
              hideSuggestions();
              return;
            }
            if (activeSuggestInput === inputEl) hideSuggestions();
          });
        }

        document.getElementById("waypoints").addEventListener("focusin", (e) => {
          const input = e.target.closest ? e.target.closest(".waypoint-row input") : null;
          if (input && input.type === "text") {
            activeSuggestInput = input;
          }
        });

        document.getElementById("waypoints").addEventListener("focusout", (e) => {
          const input = e.target.closest ? e.target.closest(".waypoint-row input") : null;
          if (!input) return;
          setTimeout(() => {
            const activeEl = document.activeElement;
            const activeIsWaypoint = activeEl && activeEl.closest && activeEl.closest("#waypoints") && activeEl.closest(".waypoint-row") && activeEl.type === "text";
            if (activeEl !== input && !dropdown.contains(activeEl) && !activeIsWaypoint) {
              hideSuggestions();
            }
          }, 150);
        });

        document.getElementById("waypoints").addEventListener("input", (e) => {
          const input = e.target.closest ? e.target.closest(".waypoint-row input") : null;
          if (!input || input.type !== "text") return;
          activeSuggestInput = input;
          if (suggestTimeout) clearTimeout(suggestTimeout);
          suggestTimeout = setTimeout(() => runSuggest(input), SUGGEST_DEBOUNCE_MS);
        });

        document.getElementById("waypoints").addEventListener("keydown", (e) => {
          const input = e.target.closest ? e.target.closest(".waypoint-row input") : null;
          if (!input) return;
          if (e.key === "Escape") {
            hideSuggestions();
            suggestTimeout && clearTimeout(suggestTimeout);
            suggestTimeout = null;
          }
        });

        document.getElementById("waypoints").addEventListener("waypoint-row-removed", () => {
          if (suggestTimeout) {
            clearTimeout(suggestTimeout);
            suggestTimeout = null;
          }
          hideSuggestions();
        });

        dropdown.addEventListener("click", (e) => {
          const item = e.target.closest(".waypoint-suggestion-item");
          if (!item || !activeSuggestInput) return;
          if (!isInputValid(activeSuggestInput)) {
            activeSuggestInput = null;
            hideSuggestions();
            return;
          }
          const placeName = item.getAttribute("data-place-name");
          if (placeName) {
            activeSuggestInput.value = placeName;
            activeSuggestInput.focus();
          }
          hideSuggestions();
        });
      })();

      async function getRoute() {
        const errorEl = document.getElementById("error");
        errorEl.textContent = "";

        const wrap = document.getElementById("drawRouteWrap");
        const btn = document.getElementById("drawRouteBtn");

        const queries = Array.from(getWaypointInputs())
          .map((i) => i.value.trim())
          .filter(Boolean);
        if (queries.length < 2) {
          errorEl.textContent = "Enter at least 2 places.";
          return;
        }

        wrap?.classList.add("loading");
        btn.disabled = true;

        try {
          const geocode = (q) =>
            fetch(
              `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json?access_token=${mapboxgl.accessToken}`,
            ).then(async (r) => {
              const json = await r.json();
              if (!r.ok)
                throw new Error(json.message || `Geocoding HTTP ${r.status}`);
              return json;
            });

          const results = await Promise.all(queries.map((q) => geocode(q)));

          const waypoints = results.map((r) => r.features?.[0]?.center);
          const firstMissing = waypoints.findIndex((w) => !w);
          if (firstMissing !== -1) {
            errorEl.textContent = `Could not find: "${queries[firstMissing]}"`;
            return;
          }

          const modes = getLegModes();
          const routeCoords = [];
          const legLengths = [];
          let routeDistanceMeters = 0;

          for (let i = 0; i < waypoints.length - 1; i++) {
            const a = waypoints[i];
            const b = waypoints[i + 1];
            const mode = modes[i] || "drive";

            let segment;
            if (mode === "fly") {
              segment = [a, b];
              routeDistanceMeters += turf.length(turf.lineString([a, b]), {
                units: "meters",
              });
            } else {
              const profile = mode === "walk" ? "walking" : "driving";
              const coords = `${a[0]},${a[1]};${b[0]},${b[1]}`;
              const dirRes = await fetch(
                `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coords}?geometries=geojson&access_token=${mapboxgl.accessToken}`,
              ).then((r) => r.json());

              if (!dirRes.routes?.length) {
                segment = [a, b];
                setLegMode(i, "fly");
                routeDistanceMeters += turf.length(turf.lineString([a, b]), {
                  units: "meters",
                });
              } else {
                segment = dirRes.routes[0].geometry.coordinates;
                routeDistanceMeters += dirRes.routes[0].distance;
              }
            }

            legLengths.push(
              turf.length(turf.lineString(segment), { units: "kilometers" }),
            );
            if (routeCoords.length > 0) {
              routeCoords.pop();
            }
            routeCoords.push(...segment);
          }

          const route = routeCoords;
          const totalPathKm = legLengths.reduce((a, b) => a + b, 0);
          const legEndProgress =
            totalPathKm <= 0
              ? [1]
              : legLengths.map((_, i) =>
                  legLengths
                    .slice(0, i + 1)
                    .reduce((a, b) => a + b, 0) / totalPathKm,
                );

          if (map.getLayer("route")) map.removeLayer("route");
          if (map.getSource("route")) map.removeSource("route");
          currentRoute = null;
          updateAnimationUI();
          document.getElementById("exportBtn").disabled = true;

          map.addSource("route", {
            type: "geojson",
            data: {
              type: "Feature",
              geometry: { type: "LineString", coordinates: route },
            },
            lineMetrics: true,
          });
          map.addLayer({
            id: "route",
            type: "line",
            source: "route",
            paint: {
              "line-gradient": [
                "step",
                ["line-progress"],
                "#3b9dd2",
                1,
                "rgba(0,0,0,0)",
              ],
              "line-width": 6,
              "line-emissive-strength": 0.8,
            },
            layout: { "line-cap": "round", "line-join": "round" },
          });

          currentRoute = {
            type: "Feature",
            geometry: { type: "LineString", coordinates: route },
            properties: { legEndProgress, legLengths },
          };
          document.getElementById("exportBtn").disabled = false;
          updateAnimationUI();

          const numStops = queries.length;
          const maxTimePerStepMs =
            (Number(document.getElementById("maxTimePerStep").value) || 2) * 1000;
          const speedup =
            Number(document.getElementById("speedup")?.value) || 4;
          const legDurationsForDuration = getLegDurations(
            legLengths,
            maxTimePerStepMs,
            speedup,
          );
          const durationMs = legDurationsForDuration
            ? legDurationsForDuration.reduce((a, b) => a + b, 0)
            : (numStops - 1) * maxTimePerStepMs;
          document.getElementById("duration").value = Math.round((durationMs / 1000) * 10) / 10;
          if (document.getElementById("editDurationsManually")?.checked) {
            const legInputs = document.querySelectorAll(
              "#waypoints .leg-duration-input",
            );
            if (
              legDurationsForDuration &&
              legDurationsForDuration.length === legInputs.length
            ) {
              legInputs.forEach((el, i) => {
                el.value = Math.round((legDurationsForDuration[i] / 1000) * 10) / 10;
              });
              document.getElementById("duration").value = Math.round(
                (legDurationsForDuration.reduce((a, b) => a + b, 0) / 1000 * 10),
              ) / 10;
              document.getElementById("maxTimePerStep").value = Math.round(
                (Math.max(...legDurationsForDuration) / 1000) * 10,
              ) / 10;
            }
          }

          const segmentLength = routeDistanceMeters / numStops;
          const altitudeM = Math.round(
            Math.max(50000, Math.min(2000000, segmentLength * 1.5)),
          );
          document.getElementById("startAltitude").value = altitudeM;

          const bounds = new mapboxgl.LngLatBounds();
          route.forEach((c) => bounds.extend(c));
          map.fitBounds(bounds, { padding: 50, pitch: 20, bearing: 0 });
        } catch (err) {
          errorEl.textContent =
            "Error: " + (err.message || "Something went wrong");
        } finally {
          wrap?.classList.remove("loading");
          btn.disabled = false;
        }
      }

      async function animateRoute() {
        if (!currentRoute) return;
        if (animationState === "playing") {
          animationControls.pauseRequested = true;
          animationState = "paused";
          updateAnimationUI();
          return;
        }
        if (animationState === "paused") {
          animationControls.pauseRequested = false;
          animationState = "playing";
          updateAnimationUI();
          return;
        }
        setPanelOpen(false);
        animationState = "playing";
        animationControls.stopRequested = false;
        animationControls.pauseRequested = false;
        updateAnimationUI();
        try {
          const legEndProgress =
            currentRoute?.properties?.legEndProgress ?? [1];
          const manualDurations = getManualLegDurationsForAnimation(
            legEndProgress.length,
          );
          await animatePath({
            map,
            path: currentRoute,
            maxTimePerStep:
              (Number(document.getElementById("maxTimePerStep").value) || 2) * 1000,
            speedup: Number(document.getElementById("speedup")?.value) || 4,
            manualLegDurations: manualDurations ?? undefined,
            startBearing:
              Number(document.getElementById("startBearing").value) || 0,
            startAltitude:
              Number(document.getElementById("startAltitude").value) || 500000,
            pitch: Number(document.getElementById("pitch").value) || 20,
            lineGradient: document.getElementById("lineGradient").checked,
            cameraFollow: document.getElementById("cameraFollow").checked,
            bearingChange: document.getElementById("bearingChange").checked,
            controls: animationControls,
          });
        } finally {
          animationState = "idle";
          updateAnimationUI();
          setPanelOpen(true);
        }
      }

      async function exportVideo() {
        if (!currentRoute) return;
        setPanelOpen(false);
        exportInProgress = true;
        updateAnimationUI();
        const exportBtn = document.getElementById("exportBtn");
        const statusEl = document.getElementById("exportStatus");
        const mapEl = document.getElementById("map");
        const savedWidth = mapEl.style.width;
        const savedHeight = mapEl.style.height;

        exportBtn.disabled = true;
        statusEl.textContent = "Loading encoder...";

        try {
          const [encoderModule, simdModule] = await Promise.all([
            import("https://unpkg.com/mp4-h264@1.0.7/build/mp4-encoder.js"),
            import("https://unpkg.com/wasm-feature-detect?module"),
          ]);
          const loadEncoder = encoderModule.default;
          const supportsSIMD = await simdModule.simd();
          const Encoder = await loadEncoder({ simd: supportsSIMD });

          const sizeStr = document.getElementById("exportSize").value;
          const [width, height] = sizeStr.split("x").map(Number);

          mapEl.style.width = width + "px";
          mapEl.style.height = height + "px";
          map.resize();

          await map.once("idle");

          const gl = map.painter.context.gl;
          const glWidth = gl.drawingBufferWidth;
          const glHeight = gl.drawingBufferHeight;

          const encoder = Encoder.create({
            width: glWidth,
            height: glHeight,
            fps: 60,
            kbps: 64000,
            rgbFlipY: true,
          });

          const ptr = encoder.getRGBPointer();

          const captureFrame = () => {
            const pixels = encoder.memory().subarray(ptr);
            gl.readPixels(
              0,
              0,
              glWidth,
              glHeight,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              pixels,
            );
            encoder.encodeRGBPointer();
          };

          statusEl.textContent = "Exporting...";

          const legEndProgressExport =
            currentRoute?.properties?.legEndProgress ?? [1];
          const manualDurationsExport = getManualLegDurationsForAnimation(
            legEndProgressExport.length,
          );
          await animatePath({
            map,
            path: currentRoute,
            maxTimePerStep:
              (Number(document.getElementById("maxTimePerStep").value) || 2) * 1000,
            speedup: Number(document.getElementById("speedup")?.value) || 4,
            manualLegDurations: manualDurationsExport ?? undefined,
            startBearing:
              Number(document.getElementById("startBearing").value) || 0,
            startAltitude:
              Number(document.getElementById("startAltitude").value) || 500000,
            pitch: Number(document.getElementById("pitch").value) || 20,
            lineGradient: document.getElementById("lineGradient").checked,
            cameraFollow: document.getElementById("cameraFollow").checked,
            bearingChange: document.getElementById("bearingChange").checked,
            exportMode: true,
            onProgress: (p) => {
              statusEl.textContent =
                "Exporting... " + Math.round(p * 100) + "%";
            },
            onRender: captureFrame,
          });
          const mp4 = encoder.end();

          const a = document.createElement("a");
          a.href = URL.createObjectURL(new Blob([mp4], { type: "video/mp4" }));
          a.download = "route-animation.mp4";
          a.click();
          URL.revokeObjectURL(a.href);

          statusEl.textContent =
            "Done. Run ffmpeg -i route-animation.mp4 out.mp4 to compress.";
        } catch (err) {
          statusEl.textContent = "Error: " + (err.message || "Export failed");
        } finally {
          mapEl.style.width = savedWidth;
          mapEl.style.height = savedHeight;
          map.resize();
          exportBtn.disabled = false;
          exportInProgress = false;
          updateAnimationUI();
          setPanelOpen(true);
        }
      }

    </script>
  </body>
</html>
