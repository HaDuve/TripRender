<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Route Finder</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.18.1/mapbox-gl-dev.js"></script>
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v3.18.1/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <style>
      :root {
        --panel-bg: #fff;
        --panel-text: #111;
        --input-bg: #fff;
        --input-text: #111;
        --input-border: #ccc;
        --secondary-text: #666;
        --error-color: #c00;
        --btn-bg: #3b9dd2;
        --btn-hover: #2d8bc0;
      }
      body.night-mode {
        --panel-bg: #1a1a1a;
        --panel-text: #e0e0e0;
        --input-bg: #2d2d2d;
        --input-text: #e0e0e0;
        --input-border: #444;
        --secondary-text: #999;
        --error-color: #e57373;
        --btn-bg: #4a9fd9;
        --btn-hover: #3b8fc9;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, sans-serif;
      }
      #panelWrapper {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 10;
        display: flex;
        align-items: flex-start;
      }
      #panelToggle {
        width: 28px;
        min-height: 44px;
        padding: 10px 6px;
        background: var(--panel-bg);
        color: var(--panel-text);
        border: none;
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      #panelToggle:hover {
        background: var(--input-bg);
      }
      #input {
        background: var(--panel-bg);
        color: var(--panel-text);
        padding: 12px;
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
        transform: translateX(-100%);
        transition: transform 0.2s ease;
      }
      #panelWrapper.panel-open #input {
        transform: translateX(0);
      }
      #map {
        width: 100vw;
        height: 100vh;
      }
      input,
      button {
        padding: 8px 12px;
        margin: 4px 0;
        width: 260px;
        font-size: 14px;
        background: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: 6px;
      }
      button {
        cursor: pointer;
        background: var(--btn-bg);
        color: white;
        border: none;
        border-radius: 6px;
        font-weight: 500;
      }
      button:hover {
        background: var(--btn-hover);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #error {
        color: var(--error-color);
        font-size: 13px;
        margin-top: 6px;
        max-width: 260px;
      }
      .control-toggle {
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        margin: 8px 0 4px;
        user-select: none;
        color: var(--panel-text);
      }
      .control-toggle::before {
        content: "▸ ";
        display: inline-block;
        transition: transform 0.2s;
      }
      .control-toggle.expanded::before {
        transform: rotate(90deg);
      }
      #animationControls {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.2s ease-out;
      }
      #animationControls.expanded {
        max-height: 360px;
      }
      #exportStatus {
        font-size: 12px;
        color: var(--secondary-text);
        margin-top: 4px;
      }
      .control-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
        font-size: 13px;
      }
      .control-row input[type="checkbox"] {
        width: auto;
        margin: 0;
        accent-color: var(--btn-bg);
      }
      .control-row input[type="number"] {
        width: 80px;
        margin: 0 0 0 auto;
      }
      .control-row label {
        flex: 1;
        cursor: pointer;
        color: var(--panel-text);
      }
      .control-row select {
        padding: 6px 8px;
        font-size: 13px;
        background: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: 6px;
      }
      #waypoints {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      #waypoints input {
        width: 260px;
      }
      #addStopBtn {
        margin-top: 6px;
        background: transparent;
        color: var(--panel-text);
        border: 1px solid var(--input-border);
      }
      #addStopBtn:hover:not(:disabled) {
        background: var(--input-bg);
      }
    </style>
  </head>
  <body>
    <div id="panelWrapper">
      <button type="button" id="panelToggle" onclick="togglePanel()" aria-label="Toggle panel">≡</button>
      <div id="input">
      <div id="waypoints">
        <input type="text" placeholder="Start" value="New York, NY" />
        <input type="text" placeholder="End" value="Boston, MA" />
      </div>
      <button id="addStopBtn" type="button" onclick="addWaypoint()">
        Add stop
      </button>
      <button onclick="getRoute()">Draw Route</button>
      <button id="animateBtn" onclick="animateRoute()" disabled>
        Animate Route
      </button>
      <button id="exportBtn" onclick="exportVideo()" disabled>
        Export video
      </button>
      <div class="control-row">
        <input type="checkbox" id="nightMode" />
        <label for="nightMode">Night mode</label>
      </div>
      <div
        class="control-toggle"
        id="animationToggle"
        onclick="toggleAnimationControls()"
      >
        Animation controls
      </div>
      <div id="animationControls">
        <div class="control-row">
          <input type="checkbox" id="lineGradient" checked />
          <label for="lineGradient">Line gradient</label>
        </div>
        <div class="control-row">
          <input type="checkbox" id="cameraFollow" checked />
          <label for="cameraFollow">Camera follow</label>
        </div>
        <div class="control-row">
          <input type="checkbox" id="bearingChange" />
          <label for="bearingChange">Bearing change</label>
        </div>
        <div class="control-row">
          <label for="duration">Duration (ms)</label>
          <input
            type="number"
            id="duration"
            value="2000"
            min="1000"
            step="1000"
          />
        </div>
        <div class="control-row">
          <label for="startBearing">Bearing (°)</label>
          <input
            type="number"
            id="startBearing"
            value="0"
            min="-180"
            max="180"
          />
        </div>
        <div class="control-row">
          <label for="startAltitude">Altitude (m)</label>
          <input
            type="number"
            id="startAltitude"
            value="500000"
            min="100"
            step="100"
          />
        </div>
        <div class="control-row">
          <label for="pitch">Pitch (°)</label>
          <input type="number" id="pitch" value="50" min="0" max="85" />
        </div>
        <div class="control-row">
          <label for="exportSize">Export size</label>
          <select
            id="exportSize"
            style="width: 80px; margin: 0 0 0 auto; padding: 6px"
          >
            <option value="1280x720">16:9</option>
            <option value="1080x1080">1:1</option>
          </select>
        </div>
      </div>
      <div id="error"></div>
      <div id="exportStatus"></div>
      </div>
    </div>
    <div id="map"></div>

    <script>
      mapboxgl.accessToken = "__MAPBOX_TOKEN__";

      const map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/mapbox/standard",
        center: [-74.5, 40],
        zoom: 4,
      });

      const nightModeCheckbox = document.getElementById("nightMode");

      function applyNightMode(checked) {
        document.body.classList.toggle("night-mode", checked);
        const setMapPreset = () =>
          map.setConfigProperty(
            "basemap",
            "lightPreset",
            checked ? "night" : "day",
          );
        if (map.isStyleLoaded()) {
          setMapPreset();
        } else {
          map.once("load", setMapPreset);
        }
        try {
          localStorage.setItem("nightMode", checked ? "1" : "0");
        } catch (_) {}
      }

      const savedNightMode = localStorage.getItem("nightMode") === "1";
      nightModeCheckbox.checked = savedNightMode;
      applyNightMode(savedNightMode);

      nightModeCheckbox.addEventListener("change", (e) => {
        applyNightMode(e.target.checked);
      });

      let currentRoute = null;

      function lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
      }

      let _previousCameraPosition = null;

      function computeCameraPosition(
        pitch,
        bearing,
        targetPosition,
        altitude,
        smooth = false,
      ) {
        const bearingInRadian = bearing / 57.29;
        const pitchInRadian = (90 - pitch) / 57.29;
        const lngDiff =
          ((altitude / Math.tan(pitchInRadian)) * Math.sin(-bearingInRadian)) /
          70000;
        const latDiff =
          ((altitude / Math.tan(pitchInRadian)) * Math.cos(-bearingInRadian)) /
          110000;
        const newCameraPosition = {
          lng: targetPosition.lng + lngDiff,
          lat: targetPosition.lat - latDiff,
        };
        if (smooth && _previousCameraPosition) {
          const SMOOTH_FACTOR = 0.95;
          newCameraPosition.lng = lerp(
            newCameraPosition.lng,
            _previousCameraPosition.lng,
            SMOOTH_FACTOR,
          );
          newCameraPosition.lat = lerp(
            newCameraPosition.lat,
            _previousCameraPosition.lat,
            SMOOTH_FACTOR,
          );
        }
        _previousCameraPosition = newCameraPosition;
        return newCameraPosition;
      }

      function setPanelOpen(open) {
        const wrapper = document.getElementById("panelWrapper");
        wrapper.classList.toggle("panel-open", open);
        try {
          localStorage.setItem("panelOpen", open ? "1" : "0");
        } catch (_) {}
      }

      function togglePanel() {
        const wrapper = document.getElementById("panelWrapper");
        setPanelOpen(!wrapper.classList.contains("panel-open"));
      }

      (function initPanelState() {
        try {
          const saved = localStorage.getItem("panelOpen");
          if (saved !== null)
            document.getElementById("panelWrapper").classList.toggle("panel-open", saved === "1");
        } catch (_) {}
      })();

      function toggleAnimationControls() {
        const toggle = document.getElementById("animationToggle");
        const panel = document.getElementById("animationControls");
        toggle.classList.toggle("expanded");
        panel.classList.toggle("expanded");
      }

      function updateAnimationFrame(
        map,
        path,
        pathDistance,
        animationPhase,
        opts,
      ) {
        const {
          startBearing,
          startAltitude,
          pitch,
          lineGradient,
          cameraFollow,
          bearingChange,
        } = opts;
        if (lineGradient) {
          map.setPaintProperty("route", "line-gradient", [
            "step",
            ["line-progress"],
            "#3b9dd2",
            animationPhase,
            "rgba(0,0,0,0)",
          ]);
        }
        if (cameraFollow) {
          const [lng, lat] = turf.along(path, pathDistance * animationPhase)
            .geometry.coordinates;
          const lngLat = { lng, lat };
          const bearing = bearingChange
            ? startBearing - animationPhase * 200
            : startBearing;
          const correctedPosition = computeCameraPosition(
            pitch,
            bearing,
            lngLat,
            startAltitude,
            true,
          );
          const camera = map.getFreeCameraOptions();
          camera.setPitchBearing(pitch, bearing);
          camera.position = mapboxgl.MercatorCoordinate.fromLngLat(
            correctedPosition,
            startAltitude,
          );
          map.setFreeCameraOptions(camera);
        }
      }

      function animatePath({
        map,
        path,
        duration,
        startBearing,
        startAltitude,
        pitch,
        lineGradient,
        cameraFollow,
        bearingChange,
        exportMode = false,
        onProgress,
        onRender,
      }) {
        _previousCameraPosition = null;
        const pathDistance = turf.length(path);
        const opts = {
          startBearing,
          startAltitude,
          pitch,
          lineGradient,
          cameraFollow,
          bearingChange,
        };

        if (exportMode) {
          return new Promise((resolve) => {
            let now =
              typeof performance !== "undefined" ? performance.now() : 0;
            const startTime = now;
            if (typeof mapboxgl.setNow === "function") mapboxgl.setNow(now);

            // Capture on each render (Mapbox video-export: readPixels when map has drawn)
            const captureFrame = () => {
              const animationPhase = (now - startTime) / duration;
              if (onProgress) onProgress(animationPhase);
              if (onRender) onRender();
            };

            // Custom layer drives the render loop (like Mapbox easeTo)
            const driverLayer = {
              id: "_export-driver",
              type: "custom",
              onAdd() {},
              render(gl, matrix) {
                now += 1000 / 60;
                if (typeof mapboxgl.setNow === "function")
                  mapboxgl.setNow(now);
                const animationPhase = (now - startTime) / duration;
                if (animationPhase > 1) {
                  map.removeLayer("_export-driver");
                  map.off("render", captureFrame);
                  if (typeof mapboxgl.restoreNow === "function")
                    mapboxgl.restoreNow();
                  resolve();
                  return;
                }
                updateAnimationFrame(
                  map,
                  path,
                  pathDistance,
                  Math.min(animationPhase, 1),
                  opts,
                );
                map.triggerRepaint();
              },
            };

            map.on("render", captureFrame);
            updateAnimationFrame(map, path, pathDistance, 0, opts);
            map.addLayer(driverLayer);
          });
        }

        return new Promise((resolve) => {
          let startTime;
          const frame = (currentTime) => {
            if (!startTime) startTime = currentTime;
            const animationPhase = (currentTime - startTime) / duration;

            if (animationPhase > 1) {
              resolve();
              return;
            }

            updateAnimationFrame(map, path, pathDistance, animationPhase, opts);
            requestAnimationFrame(frame);
          };

          requestAnimationFrame(frame);
        });
      }

      const MAX_WAYPOINTS = 24;

      function getWaypointInputs() {
        return document.querySelectorAll("#waypoints input");
      }

      function updateAddStopState() {
        const btn = document.getElementById("addStopBtn");
        btn.disabled = getWaypointInputs().length >= MAX_WAYPOINTS;
      }

      function addWaypoint() {
        if (getWaypointInputs().length >= MAX_WAYPOINTS) return;
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = "Stop";
        document.getElementById("waypoints").appendChild(input);
        updateAddStopState();
        input.focus();
      }

      async function getRoute() {
        const errorEl = document.getElementById("error");
        errorEl.textContent = "";

        const queries = Array.from(getWaypointInputs())
          .map((i) => i.value.trim())
          .filter(Boolean);
        if (queries.length < 2) {
          errorEl.textContent = "Enter at least 2 places.";
          return;
        }

        try {
          const geocode = (q) =>
            fetch(
              `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json?access_token=${mapboxgl.accessToken}`,
            ).then((r) => r.json());

          const results = await Promise.all(queries.map((q) => geocode(q)));

          const waypoints = results.map((r) => r.features?.[0]?.center);
          const firstMissing = waypoints.findIndex((w) => !w);
          if (firstMissing !== -1) {
            errorEl.textContent = `Could not find: "${queries[firstMissing]}"`;
            return;
          }

          const coords = waypoints
            .map((c) => `${c[0]},${c[1]}`)
            .join(";");
          const dirRes = await fetch(
            `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?geometries=geojson&access_token=${mapboxgl.accessToken}`,
          ).then((r) => r.json());

          if (!dirRes.routes?.length) {
            errorEl.textContent = "No route found between these places.";
            return;
          }

          const route = dirRes.routes[0].geometry.coordinates;

          if (map.getLayer("route")) map.removeLayer("route");
          if (map.getSource("route")) map.removeSource("route");
          currentRoute = null;
          document.getElementById("animateBtn").disabled = true;
          document.getElementById("exportBtn").disabled = true;

          map.addSource("route", {
            type: "geojson",
            data: {
              type: "Feature",
              geometry: { type: "LineString", coordinates: route },
            },
            lineMetrics: true,
          });
          map.addLayer({
            id: "route",
            type: "line",
            source: "route",
            paint: {
              "line-gradient": [
                "step",
                ["line-progress"],
                "#3b9dd2",
                1,
                "rgba(0,0,0,0)",
              ],
              "line-width": 6,
              "line-emissive-strength": 0.8,
            },
            layout: { "line-cap": "round", "line-join": "round" },
          });

          currentRoute = {
            type: "Feature",
            geometry: { type: "LineString", coordinates: route },
          };
          document.getElementById("animateBtn").disabled = false;
          document.getElementById("exportBtn").disabled = false;

          const bounds = new mapboxgl.LngLatBounds();
          route.forEach((c) => bounds.extend(c));
          map.fitBounds(bounds, { padding: 50, pitch: 50, bearing: 0 });
        } catch (err) {
          errorEl.textContent =
            "Error: " + (err.message || "Something went wrong");
        }
      }

      async function animateRoute() {
        if (!currentRoute) return;
        setPanelOpen(false);
        const btn = document.getElementById("animateBtn");
        btn.disabled = true;
        try {
          await animatePath({
            map,
            path: currentRoute,
            duration: Number(document.getElementById("duration").value) || 2000,
            startBearing:
              Number(document.getElementById("startBearing").value) || 0,
            startAltitude:
              Number(document.getElementById("startAltitude").value) || 500000,
            pitch: Number(document.getElementById("pitch").value) || 50,
            lineGradient: document.getElementById("lineGradient").checked,
            cameraFollow: document.getElementById("cameraFollow").checked,
            bearingChange: document.getElementById("bearingChange").checked,
          });
        } finally {
          btn.disabled = false;
          setPanelOpen(true);
        }
      }

      async function exportVideo() {
        if (!currentRoute) return;
        setPanelOpen(false);
        const exportBtn = document.getElementById("exportBtn");
        const statusEl = document.getElementById("exportStatus");
        const mapEl = document.getElementById("map");
        const savedWidth = mapEl.style.width;
        const savedHeight = mapEl.style.height;

        exportBtn.disabled = true;
        statusEl.textContent = "Loading encoder...";

        try {
          const [encoderModule, simdModule] = await Promise.all([
            import("https://unpkg.com/mp4-h264@1.0.7/build/mp4-encoder.js"),
            import("https://unpkg.com/wasm-feature-detect?module"),
          ]);
          const loadEncoder = encoderModule.default;
          const supportsSIMD = await simdModule.simd();
          const Encoder = await loadEncoder({ simd: supportsSIMD });

          const sizeStr = document.getElementById("exportSize").value;
          const [width, height] = sizeStr.split("x").map(Number);

          mapEl.style.width = width + "px";
          mapEl.style.height = height + "px";
          map.resize();

          await map.once("idle");

          const gl = map.painter.context.gl;
          const glWidth = gl.drawingBufferWidth;
          const glHeight = gl.drawingBufferHeight;

          const encoder = Encoder.create({
            width: glWidth,
            height: glHeight,
            fps: 60,
            kbps: 64000,
            rgbFlipY: true,
          });

          const ptr = encoder.getRGBPointer();

          const captureFrame = () => {
            const pixels = encoder.memory().subarray(ptr);
            gl.readPixels(
              0,
              0,
              glWidth,
              glHeight,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              pixels,
            );
            encoder.encodeRGBPointer();
          };

          statusEl.textContent = "Exporting...";

          const duration =
            Number(document.getElementById("duration").value) || 2000;
          await animatePath({
            map,
            path: currentRoute,
            duration,
            startBearing:
              Number(document.getElementById("startBearing").value) || 0,
            startAltitude:
              Number(document.getElementById("startAltitude").value) || 500000,
            pitch: Number(document.getElementById("pitch").value) || 50,
            lineGradient: document.getElementById("lineGradient").checked,
            cameraFollow: document.getElementById("cameraFollow").checked,
            bearingChange: document.getElementById("bearingChange").checked,
            exportMode: true,
            onProgress: (p) => {
              statusEl.textContent =
                "Exporting... " + Math.round(p * 100) + "%";
            },
            onRender: captureFrame,
          });
          const mp4 = encoder.end();

          const a = document.createElement("a");
          a.href = URL.createObjectURL(new Blob([mp4], { type: "video/mp4" }));
          a.download = "route-animation.mp4";
          a.click();
          URL.revokeObjectURL(a.href);

          statusEl.textContent =
            "Done. Run ffmpeg -i route-animation.mp4 out.mp4 to compress.";
        } catch (err) {
          statusEl.textContent = "Error: " + (err.message || "Export failed");
        } finally {
          mapEl.style.width = savedWidth;
          mapEl.style.height = savedHeight;
          map.resize();
          exportBtn.disabled = false;
          setPanelOpen(true);
        }
      }
    </script>
  </body>
</html>
