<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Route Finder</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.18.1/mapbox-gl-dev.js"></script>
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v3.18.1/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <style>
      :root {
        --panel-bg: #fff;
        --panel-text: #111;
        --input-bg: #fff;
        --input-text: #111;
        --input-border: #ccc;
        --secondary-text: #666;
        --error-color: #c00;
        --btn-bg: #3b9dd2;
        --btn-hover: #2d8bc0;
      }
      body.night-mode {
        --panel-bg: #1a1a1a;
        --panel-text: #e0e0e0;
        --input-bg: #2d2d2d;
        --input-text: #e0e0e0;
        --input-border: #444;
        --secondary-text: #999;
        --error-color: #e57373;
        --btn-bg: #4a9fd9;
        --btn-hover: #3b8fc9;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, sans-serif;
      }
      #panelWrapper {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 10;
        display: flex;
        align-items: flex-start;
      }
      #panelWrapper #panelToggle {
        width: 44px;
        min-width: 44px;
        min-height: 48px;
        padding: 0;
        margin: 0;
        background: var(--panel-bg);
        color: var(--panel-text);
        border: none;
        border-right: 1px solid var(--input-border);
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 12px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      #panelWrapper #panelToggle svg {
        width: 22px;
        height: 22px;
        fill: currentColor;
      }
      #panelWrapper #panelToggle:hover {
        background: var(--input-bg);
      }
      #panelWrapper #input {
        width: auto;
        min-width: 280px;
        max-height: 100vh;
        overflow-x: hidden;
        overflow-y: auto;
        background: var(--panel-bg);
        color: var(--panel-text);
        padding: 12px;
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
        transform: translateX(calc(-100% - 44px));
        transition: transform 0.2s ease;
      }
      #panelWrapper.panel-open #input {
        transform: translateX(0);
      }
      #panelWrapper:not(.panel-open) #input {
        pointer-events: none;
      }
      #map {
        width: 100vw;
        height: 100vh;
      }
      input,
      button {
        padding: 8px 12px;
        margin: 4px 0;
        width: 260px;
        font-size: 14px;
        background: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: 6px;
      }
      button {
        cursor: pointer;
        background: var(--btn-bg);
        color: white;
        border: none;
        border-radius: 6px;
        font-weight: 500;
      }
      button:hover {
        background: var(--btn-hover);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #error {
        color: var(--error-color);
        font-size: 13px;
        margin-top: 6px;
        max-width: 260px;
      }
      .control-toggle {
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        margin: 8px 0 4px;
        user-select: none;
        color: var(--panel-text);
      }
      .control-toggle::before {
        content: "▸ ";
        display: inline-block;
        transition: transform 0.2s;
      }
      .control-toggle.expanded::before {
        transform: rotate(90deg);
      }
      #animationControls {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.2s ease-out;
      }
      #animationControls.expanded {
        max-height: 360px;
      }
      #exportStatus {
        font-size: 12px;
        color: var(--secondary-text);
        margin-top: 4px;
      }
      .control-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
        font-size: 13px;
      }
      .control-row input[type="checkbox"] {
        width: auto;
        margin: 0;
        accent-color: var(--btn-bg);
      }
      .control-row input[type="number"] {
        width: 80px;
        margin: 0 0 0 auto;
      }
      .control-row label {
        flex: 1;
        cursor: pointer;
        color: var(--panel-text);
      }
      .control-row select {
        padding: 6px 8px;
        font-size: 13px;
        background: var(--input-bg);
        color: var(--input-text);
        border: 1px solid var(--input-border);
        border-radius: 6px;
      }
      #waypoints {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      #waypoints input {
        width: 260px;
      }
      .leg-control {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 2px 0;
        font-size: 12px;
      }
      .leg-control label {
        flex: 0 0 auto;
        color: var(--secondary-text);
        margin: 0;
      }
      .leg-control select.leg-mode {
        width: auto;
        min-width: 90px;
        margin: 0;
        padding: 4px 8px;
        font-size: 12px;
      }
      #addStopBtn {
        margin-top: 6px;
        background: transparent;
        color: var(--panel-text);
        border: 1px solid var(--input-border);
      }
      #addStopBtn:hover:not(:disabled) {
        background: var(--input-bg);
      }
    </style>
  </head>
  <body>
    <div id="panelWrapper">
      <button
        type="button"
        id="panelToggle"
        onclick="togglePanel()"
        aria-label="Toggle panel"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z" />
        </svg>
      </button>
      <div id="input">
        <div id="waypoints">
          <input type="text" placeholder="Start" value="New York, NY" />
          <div class="leg-control control-row">
            <label>To next:</label>
            <select class="leg-mode">
              <option value="walk">Walk</option>
              <option value="drive" selected>Drive</option>
              <option value="fly">Fly</option>
            </select>
          </div>
          <input type="text" placeholder="End" value="Boston, MA" />
        </div>
        <button id="addStopBtn" type="button" onclick="addWaypoint()">
          Add stop
        </button>
        <button onclick="getRoute()">Draw Route</button>
        <button id="animateBtn" onclick="animateRoute()" disabled>
          Animate Route
        </button>
        <button id="exportBtn" onclick="exportVideo()" disabled>
          Export video
        </button>
        <div class="control-row">
          <input type="checkbox" id="nightMode" />
          <label for="nightMode">Night mode</label>
        </div>
        <div
          class="control-toggle"
          id="animationToggle"
          onclick="toggleAnimationControls()"
        >
          Animation controls
        </div>
        <div id="animationControls">
          <div class="control-row">
            <input type="checkbox" id="lineGradient" checked />
            <label for="lineGradient">Line gradient</label>
          </div>
          <div class="control-row">
            <input type="checkbox" id="cameraFollow" checked />
            <label for="cameraFollow">Camera follow</label>
          </div>
          <div class="control-row">
            <input type="checkbox" id="bearingChange" />
            <label for="bearingChange">Bearing change</label>
          </div>
          <div class="control-row">
            <label for="duration">Duration (ms)</label>
            <input
              type="number"
              id="duration"
              value="2000"
              min="1000"
              step="1000"
            />
          </div>
          <div class="control-row">
            <label for="maxTimePerStep">Max time per step (ms)</label>
            <input
              type="number"
              id="maxTimePerStep"
              value="2000"
              min="500"
              step="500"
            />
          </div>
          <div class="control-row">
            <label for="speedup">Max speedup (1–4)</label>
            <input
              type="number"
              id="speedup"
              value="4"
              min="1"
              max="4"
              step="1"
            />
          </div>
          <div class="control-row">
            <label for="startBearing">Bearing (°)</label>
            <input
              type="number"
              id="startBearing"
              value="0"
              min="-180"
              max="180"
            />
          </div>
          <div class="control-row">
            <label for="startAltitude">Altitude (m)</label>
            <input
              type="number"
              id="startAltitude"
              value="500000"
              min="100"
              step="100"
            />
          </div>
          <div class="control-row">
            <label for="pitch">Pitch (°)</label>
            <input type="number" id="pitch" value="20" min="0" max="85" />
          </div>
          <div class="control-row">
            <label for="exportSize">Export size</label>
            <select
              id="exportSize"
              style="width: 80px; margin: 0 0 0 auto; padding: 6px"
            >
              <option value="1280x720">16:9</option>
              <option value="1080x1080">1:1</option>
            </select>
          </div>
        </div>
        <div id="error"></div>
        <div id="exportStatus"></div>
      </div>
    </div>
    <div id="map"></div>

    <script>
      mapboxgl.accessToken = "__MAPBOX_TOKEN__";

      const map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/mapbox/standard",
        center: [-74.5, 40],
        zoom: 4,
      });

      const nightModeCheckbox = document.getElementById("nightMode");

      function applyNightMode(checked) {
        document.body.classList.toggle("night-mode", checked);
        const setMapPreset = () =>
          map.setConfigProperty(
            "basemap",
            "lightPreset",
            checked ? "night" : "day",
          );
        if (map.isStyleLoaded()) {
          setMapPreset();
        } else {
          map.once("load", setMapPreset);
        }
        try {
          localStorage.setItem("nightMode", checked ? "1" : "0");
        } catch (_) {}
      }

      const savedNightMode = localStorage.getItem("nightMode") === "1";
      nightModeCheckbox.checked = savedNightMode;
      applyNightMode(savedNightMode);

      nightModeCheckbox.addEventListener("change", (e) => {
        applyNightMode(e.target.checked);
      });

      let currentRoute = null;

      function lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
      }

      // --- Mercator & camera math (see Mapbox blog: building-cinematic-route-animations-with-mapboxgl) ---
      // Web Mercator (EPSG:3857): x = R*lng*π/180, y = R*ln(tan(π/4 + lat*π/360)). R ≈ 20037508.34 m.
      function mercatorDistanceMeters(a, b) {
        const toM = (lng, lat) => {
          const x = (lng * 20037508.34) / 180;
          const y =
            Math.log(Math.tan((90 + lat) * (Math.PI / 360))) *
            (20037508.34 / Math.PI);
          return { x, y };
        };
        const p = toM(a[0], a[1]);
        const q = toM(b[0], b[1]);
        return Math.hypot(q.x - p.x, q.y - p.y);
      }

      // Progress 0..1 along route using Mercator segment lengths (matches Mapbox line-progress).
      function pointAlongRouteByProgress(coords, progress) {
        if (!coords.length) return coords[0];
        if (coords.length === 1 || progress <= 0) return coords[0];
        let total = 0;
        const segLengths = [];
        for (let i = 1; i < coords.length; i++) {
          const d = mercatorDistanceMeters(coords[i - 1], coords[i]);
          segLengths.push(d);
          total += d;
        }
        if (total <= 0 || progress >= 1) return coords[coords.length - 1];
        const target = progress * total;
        let acc = 0;
        for (let i = 0; i < segLengths.length; i++) {
          if (acc + segLengths[i] >= target) {
            const t = (target - acc) / segLengths[i];
            return [
              lerp(coords[i][0], coords[i + 1][0], t),
              lerp(coords[i][1], coords[i + 1][1], t),
            ];
          }
          acc += segLengths[i];
        }
        return coords[coords.length - 1];
      }

      function pointAlongRoute(coords, distanceKm) {
        if (!coords.length) return coords[0];
        if (coords.length === 1 || distanceKm <= 0) return coords[0];
        const totalKm = turf.length(turf.lineString(coords), {
          units: "kilometers",
        });
        if (distanceKm >= totalKm) return coords[coords.length - 1];
        let acc = 0;
        for (let i = 1; i < coords.length; i++) {
          const seg = [coords[i - 1], coords[i]];
          const segKm = turf.length(turf.lineString(seg), {
            units: "kilometers",
          });
          if (acc + segKm >= distanceKm) {
            const t = (distanceKm - acc) / segKm;
            return [
              lerp(coords[i - 1][0], coords[i][0], t),
              lerp(coords[i - 1][1], coords[i][1], t),
            ];
          }
          acc += segKm;
        }
        return coords[coords.length - 1];
      }

      let _previousCameraPosition = null;
      let _previousCameraTarget = null;

      // More south (lower lat) → lower pitch (look more down). Base pitch is at equator; scales with lat.
      function pitchForLatitude(basePitch, lat) {
        const PITCH_PER_DEG_LAT = 0.3;
        const p = basePitch + lat * PITCH_PER_DEG_LAT;
        return Math.max(0, Math.min(85, p));
      }

      // Camera position from target on ground: same idea as Mapbox blog (bearing/pitch/altitude → offset).
      // Radians: 57.2958 ≈ 180/π. Longitude: meters per degree = 111e3*cos(lat) ≈ 70e3 at mid-lat; we use cos(lat).
      // Latitude: ~111 km/degree. offsetScale=0 → camera directly above target.
      function computeCameraPosition(
        pitch,
        bearing,
        targetPosition,
        altitude,
        smooth = false,
        offsetScale = 1,
      ) {
        const rad = Math.PI / 180;
        const bearingRad = bearing * rad;
        const pitchRad = (90 - pitch) * rad;
        const latRad = targetPosition.lat * rad;
        const metersPerDegLng = 111000 * Math.max(0.01, Math.cos(latRad));
        const lngDiff =
          (offsetScale *
            ((altitude / Math.tan(pitchRad)) * Math.sin(-bearingRad))) /
          metersPerDegLng;
        const latDiff =
          (offsetScale *
            ((altitude / Math.tan(pitchRad)) * Math.cos(-bearingRad))) /
          111000;
        const newCameraPosition = {
          lng: targetPosition.lng + lngDiff,
          lat: targetPosition.lat - latDiff,
        };
        if (smooth && _previousCameraPosition) {
          const SMOOTH_FACTOR = 0.95;
          newCameraPosition.lng = lerp(
            newCameraPosition.lng,
            _previousCameraPosition.lng,
            SMOOTH_FACTOR,
          );
          newCameraPosition.lat = lerp(
            newCameraPosition.lat,
            _previousCameraPosition.lat,
            SMOOTH_FACTOR,
          );
        }
        _previousCameraPosition = newCameraPosition;
        return newCameraPosition;
      }

      function setPanelOpen(open) {
        const wrapper = document.getElementById("panelWrapper");
        wrapper.classList.toggle("panel-open", open);
        try {
          localStorage.setItem("panelOpen", open ? "1" : "0");
        } catch (_) {}
      }

      (function initPanelState() {
        try {
          const saved = localStorage.getItem("panelOpen");
          const open = saved !== null ? saved === "1" : true;
          document
            .getElementById("panelWrapper")
            .classList.toggle("panel-open", open);
        } catch (_) {}
      })();

      function togglePanel() {
        const wrapper = document.getElementById("panelWrapper");
        setPanelOpen(!wrapper.classList.contains("panel-open"));
      }

      function toggleAnimationControls() {
        const toggle = document.getElementById("animationToggle");
        const panel = document.getElementById("animationControls");
        toggle.classList.toggle("expanded");
        panel.classList.toggle("expanded");
      }

      function getLegDurations(legLengths, maxTimePerStep, speedup) {
        if (!legLengths?.length) return null;
        const safeSpeedup = Math.max(1, Number(speedup) || 1);
        const safeMax = Math.max(0, Number(maxTimePerStep) || 2000);
        const maxLegLength = Math.max(...legLengths, 0);
        if (maxLegLength === 0)
          return legLengths.map(() => safeMax);
        const minDur = safeMax / safeSpeedup;
        const range = safeMax - minDur;
        return legLengths.map(
          (len) => minDur + range * (len / maxLegLength),
        );
      }

      function timeToProgress(
        elapsedMs,
        legEndProgress,
        legLengths,
        maxTimePerStep,
        speedup,
      ) {
        const numLegs = legEndProgress.length;
        if (numLegs === 0) return 1;
        const legDurations = getLegDurations(legLengths, maxTimePerStep, speedup);
        const safeMax = Math.max(0, Number(maxTimePerStep) || 2000);
        const totalDuration = legDurations
          ? legDurations.reduce((a, b) => a + b, 0)
          : numLegs * safeMax;
        if (
          !Number.isFinite(totalDuration) ||
          totalDuration <= 0 ||
          elapsedMs >= totalDuration
        )
          return 1;
        const durs = legDurations ?? legEndProgress.map(() => safeMax);
        let cum = 0;
        let legIndex = 0;
        for (let i = 0; i < numLegs; i++) {
          if (elapsedMs < cum + durs[i]) {
            legIndex = i;
            break;
          }
          cum += durs[i];
          legIndex = i;
        }
        const legDur = durs[legIndex];
        const tInLeg =
          legDur <= 0 || !Number.isFinite(legDur) ? 1 : (elapsedMs - cum) / legDur;
        const progressStart =
          legIndex === 0 ? 0 : legEndProgress[legIndex - 1];
        const progressEnd = legEndProgress[legIndex];
        return progressStart + tInLeg * (progressEnd - progressStart);
      }

      function updateAnimationFrame(
        map,
        path,
        pathDistance,
        animationPhase,
        opts,
      ) {
        const {
          startBearing,
          startAltitude,
          pitch,
          lineGradient,
          cameraFollow,
          bearingChange,
        } = opts;
        if (lineGradient) {
          map.setPaintProperty("route", "line-gradient", [
            "step",
            ["line-progress"],
            "#3b9dd2",
            animationPhase,
            "rgba(0,0,0,0)",
          ]);
        }
        if (cameraFollow) {
          const coords = path.geometry?.coordinates ?? path.coordinates;
          // Use Mercator-based progress so camera aligns with line-progress (2D render).
          const [lng, lat] = coords
            ? pointAlongRouteByProgress(coords, animationPhase)
            : turf.along(path, pathDistance * animationPhase, {
                units: "kilometers",
              }).geometry.coordinates;
          let targetPosition = { lng, lat };
          // Optional lag: smooth camera target so it doesn't run ahead of the blue line.
          const CAMERA_LAG = 0.22;
          if (_previousCameraTarget) {
            targetPosition = {
              lng: lerp(_previousCameraTarget.lng, targetPosition.lng, CAMERA_LAG),
              lat: lerp(_previousCameraTarget.lat, targetPosition.lat, CAMERA_LAG),
            };
          }
          _previousCameraTarget = targetPosition;
          const effectivePitch = pitchForLatitude(pitch, targetPosition.lat);
          // offsetScale=1 so camera is placed behind the target; view ray then hits the progress point.
          const cameraPos = computeCameraPosition(
            effectivePitch,
            startBearing,
            targetPosition,
            startAltitude,
            false,
            1,
          );
          const camera = map.getFreeCameraOptions();
          camera.position = mapboxgl.MercatorCoordinate.fromLngLat(
            [cameraPos.lng, cameraPos.lat],
            startAltitude,
          );
          camera.setPitchBearing(effectivePitch, startBearing);
          map.setFreeCameraOptions(camera);
        }
      }

      function animatePath({
        map,
        path,
        maxTimePerStep,
        speedup,
        startBearing,
        startAltitude,
        pitch,
        lineGradient,
        cameraFollow,
        bearingChange,
        exportMode = false,
        onProgress,
        onRender,
      }) {
        _previousCameraPosition = null;
        _previousCameraTarget = null;
        const line = path.geometry
          ? turf.lineString(path.geometry.coordinates.slice())
          : path;
        const pathDistance = turf.length(line, { units: "kilometers" });
        const legEndProgress = path.properties?.legEndProgress ?? [1];
        const legLengths = path.properties?.legLengths ?? null;
        const legDurations = getLegDurations(legLengths, maxTimePerStep, speedup);
        const duration = legDurations
          ? legDurations.reduce((a, b) => a + b, 0)
          : legEndProgress.length * maxTimePerStep;
        const opts = {
          startBearing,
          startAltitude,
          pitch,
          lineGradient,
          cameraFollow,
          bearingChange,
        };

        if (exportMode) {
          return new Promise((resolve) => {
            let now =
              typeof performance !== "undefined" ? performance.now() : 0;
            const startTime = now;
            const maxElapsed = Math.max(duration * 1.5, duration + 5000);
            if (typeof mapboxgl.setNow === "function") mapboxgl.setNow(now);

            const done = () => {
              map.removeLayer("_export-driver");
              map.off("render", captureFrame);
              if (typeof mapboxgl.restoreNow === "function")
                mapboxgl.restoreNow();
              resolve();
            };

            const captureFrame = () => {
              const elapsed = now - startTime;
              const animationPhase = timeToProgress(
                elapsed,
                legEndProgress,
                legLengths,
                maxTimePerStep,
                speedup,
              );
              if (onProgress) onProgress(Math.min(1, animationPhase));
              if (onRender) onRender();
            };

            const driverLayer = {
              id: "_export-driver",
              type: "custom",
              onAdd() {},
              render(gl, matrix) {
                now += 1000 / 60;
                if (typeof mapboxgl.setNow === "function") mapboxgl.setNow(now);
                const elapsed = now - startTime;
                if (elapsed >= duration || elapsed >= maxElapsed) {
                  done();
                  return;
                }
                const animationPhase = timeToProgress(
                  elapsed,
                  legEndProgress,
                  legLengths,
                  maxTimePerStep,
                  speedup,
                );
                if (animationPhase >= 0.9999) {
                  done();
                  return;
                }
                updateAnimationFrame(
                  map,
                  line,
                  pathDistance,
                  Math.min(animationPhase, 1),
                  opts,
                );
                map.triggerRepaint();
              },
            };

            map.on("render", captureFrame);
            updateAnimationFrame(map, line, pathDistance, 0, opts);
            map.addLayer(driverLayer);
          });
        }

        return new Promise((resolve) => {
          let startTime;
          const frame = (currentTime) => {
            if (!startTime) startTime = currentTime;
            const elapsed = currentTime - startTime;
            const animationPhase = timeToProgress(
              elapsed,
              legEndProgress,
              legLengths,
              maxTimePerStep,
              speedup,
            );

            if (animationPhase >= 1) {
              resolve();
              return;
            }

            updateAnimationFrame(map, line, pathDistance, animationPhase, opts);
            requestAnimationFrame(frame);
          };

          requestAnimationFrame(frame);
        });
      }

      const MAX_WAYPOINTS = 24;

      function getWaypointInputs() {
        return document.querySelectorAll("#waypoints input");
      }

      function getLegModes() {
        return Array.from(
          document.querySelectorAll("#waypoints .leg-mode"),
        ).map((el) =>
          el.value === "walk" || el.value === "fly" ? el.value : "drive",
        );
      }

      function setLegMode(legIndex, mode) {
        const selects = document.querySelectorAll("#waypoints .leg-mode");
        const el = selects[legIndex];
        if (el) el.value = mode;
      }

      function updateAddStopState() {
        const btn = document.getElementById("addStopBtn");
        btn.disabled = getWaypointInputs().length >= MAX_WAYPOINTS;
      }

      function createLegControl() {
        const div = document.createElement("div");
        div.className = "leg-control control-row";
        const label = document.createElement("label");
        label.textContent = "To next:";
        const select = document.createElement("select");
        select.className = "leg-mode";
        ["walk", "drive", "fly"].forEach((val) => {
          const opt = document.createElement("option");
          opt.value = val;
          opt.textContent = val.charAt(0).toUpperCase() + val.slice(1);
          if (val === "drive") opt.selected = true;
          select.appendChild(opt);
        });
        div.appendChild(label);
        div.appendChild(select);
        return div;
      }

      function addWaypoint() {
        if (getWaypointInputs().length >= MAX_WAYPOINTS) return;
        const container = document.getElementById("waypoints");
        container.appendChild(createLegControl());
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = "Stop";
        container.appendChild(input);
        updateAddStopState();
        input.focus();
      }

      async function getRoute() {
        const errorEl = document.getElementById("error");
        errorEl.textContent = "";

        const queries = Array.from(getWaypointInputs())
          .map((i) => i.value.trim())
          .filter(Boolean);
        if (queries.length < 2) {
          errorEl.textContent = "Enter at least 2 places.";
          return;
        }

        try {
          const geocode = (q) =>
            fetch(
              `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json?access_token=${mapboxgl.accessToken}`,
            ).then(async (r) => {
              const json = await r.json();
              if (!r.ok)
                throw new Error(json.message || `Geocoding HTTP ${r.status}`);
              return json;
            });

          const results = await Promise.all(queries.map((q) => geocode(q)));

          const waypoints = results.map((r) => r.features?.[0]?.center);
          const firstMissing = waypoints.findIndex((w) => !w);
          if (firstMissing !== -1) {
            errorEl.textContent = `Could not find: "${queries[firstMissing]}"`;
            return;
          }

          const modes = getLegModes();
          const routeCoords = [];
          const legLengths = [];
          let routeDistanceMeters = 0;

          for (let i = 0; i < waypoints.length - 1; i++) {
            const a = waypoints[i];
            const b = waypoints[i + 1];
            const mode = modes[i] || "drive";

            let segment;
            if (mode === "fly") {
              segment = [a, b];
              routeDistanceMeters += turf.length(turf.lineString([a, b]), {
                units: "meters",
              });
            } else {
              const profile = mode === "walk" ? "walking" : "driving";
              const coords = `${a[0]},${a[1]};${b[0]},${b[1]}`;
              const dirRes = await fetch(
                `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coords}?geometries=geojson&access_token=${mapboxgl.accessToken}`,
              ).then((r) => r.json());

              if (!dirRes.routes?.length) {
                segment = [a, b];
                setLegMode(i, "fly");
                routeDistanceMeters += turf.length(turf.lineString([a, b]), {
                  units: "meters",
                });
              } else {
                segment = dirRes.routes[0].geometry.coordinates;
                routeDistanceMeters += dirRes.routes[0].distance;
              }
            }

            legLengths.push(
              turf.length(turf.lineString(segment), { units: "kilometers" }),
            );
            if (routeCoords.length > 0) {
              routeCoords.pop();
            }
            routeCoords.push(...segment);
          }

          const route = routeCoords;
          const totalPathKm = legLengths.reduce((a, b) => a + b, 0);
          const legEndProgress =
            totalPathKm <= 0
              ? [1]
              : legLengths.map((_, i) =>
                  legLengths
                    .slice(0, i + 1)
                    .reduce((a, b) => a + b, 0) / totalPathKm,
                );

          if (map.getLayer("route")) map.removeLayer("route");
          if (map.getSource("route")) map.removeSource("route");
          currentRoute = null;
          document.getElementById("animateBtn").disabled = true;
          document.getElementById("exportBtn").disabled = true;

          map.addSource("route", {
            type: "geojson",
            data: {
              type: "Feature",
              geometry: { type: "LineString", coordinates: route },
            },
            lineMetrics: true,
          });
          map.addLayer({
            id: "route",
            type: "line",
            source: "route",
            paint: {
              "line-gradient": [
                "step",
                ["line-progress"],
                "#3b9dd2",
                1,
                "rgba(0,0,0,0)",
              ],
              "line-width": 6,
              "line-emissive-strength": 0.8,
            },
            layout: { "line-cap": "round", "line-join": "round" },
          });

          currentRoute = {
            type: "Feature",
            geometry: { type: "LineString", coordinates: route },
            properties: { legEndProgress, legLengths },
          };
          document.getElementById("animateBtn").disabled = false;
          document.getElementById("exportBtn").disabled = false;

          const numStops = queries.length;
          const maxTimePerStep =
            Number(document.getElementById("maxTimePerStep").value) || 2000;
          const speedup =
            Number(document.getElementById("speedup")?.value) || 4;
          const legDurationsForDuration = getLegDurations(
            legLengths,
            maxTimePerStep,
            speedup,
          );
          const durationMs = legDurationsForDuration
            ? legDurationsForDuration.reduce((a, b) => a + b, 0)
            : (numStops - 1) * maxTimePerStep;
          document.getElementById("duration").value = Math.round(durationMs);

          const segmentLength = routeDistanceMeters / numStops;
          const altitudeM = Math.round(
            Math.max(50000, Math.min(2000000, segmentLength * 1.5)),
          );
          document.getElementById("startAltitude").value = altitudeM;

          const bounds = new mapboxgl.LngLatBounds();
          route.forEach((c) => bounds.extend(c));
          map.fitBounds(bounds, { padding: 50, pitch: 20, bearing: 0 });
        } catch (err) {
          errorEl.textContent =
            "Error: " + (err.message || "Something went wrong");
        }
      }

      async function animateRoute() {
        if (!currentRoute) return;
        setPanelOpen(false);
        const btn = document.getElementById("animateBtn");
        btn.disabled = true;
        try {
          await animatePath({
            map,
            path: currentRoute,
            maxTimePerStep:
              Number(document.getElementById("maxTimePerStep").value) || 2000,
            speedup: Number(document.getElementById("speedup")?.value) || 4,
            startBearing:
              Number(document.getElementById("startBearing").value) || 0,
            startAltitude:
              Number(document.getElementById("startAltitude").value) || 500000,
            pitch: Number(document.getElementById("pitch").value) || 20,
            lineGradient: document.getElementById("lineGradient").checked,
            cameraFollow: document.getElementById("cameraFollow").checked,
            bearingChange: document.getElementById("bearingChange").checked,
          });
        } finally {
          btn.disabled = false;
          setPanelOpen(true);
        }
      }

      async function exportVideo() {
        if (!currentRoute) return;
        setPanelOpen(false);
        const exportBtn = document.getElementById("exportBtn");
        const statusEl = document.getElementById("exportStatus");
        const mapEl = document.getElementById("map");
        const savedWidth = mapEl.style.width;
        const savedHeight = mapEl.style.height;

        exportBtn.disabled = true;
        statusEl.textContent = "Loading encoder...";

        try {
          const [encoderModule, simdModule] = await Promise.all([
            import("https://unpkg.com/mp4-h264@1.0.7/build/mp4-encoder.js"),
            import("https://unpkg.com/wasm-feature-detect?module"),
          ]);
          const loadEncoder = encoderModule.default;
          const supportsSIMD = await simdModule.simd();
          const Encoder = await loadEncoder({ simd: supportsSIMD });

          const sizeStr = document.getElementById("exportSize").value;
          const [width, height] = sizeStr.split("x").map(Number);

          mapEl.style.width = width + "px";
          mapEl.style.height = height + "px";
          map.resize();

          await map.once("idle");

          const gl = map.painter.context.gl;
          const glWidth = gl.drawingBufferWidth;
          const glHeight = gl.drawingBufferHeight;

          const encoder = Encoder.create({
            width: glWidth,
            height: glHeight,
            fps: 60,
            kbps: 64000,
            rgbFlipY: true,
          });

          const ptr = encoder.getRGBPointer();

          const captureFrame = () => {
            const pixels = encoder.memory().subarray(ptr);
            gl.readPixels(
              0,
              0,
              glWidth,
              glHeight,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              pixels,
            );
            encoder.encodeRGBPointer();
          };

          statusEl.textContent = "Exporting...";

          await animatePath({
            map,
            path: currentRoute,
            maxTimePerStep:
              Number(document.getElementById("maxTimePerStep").value) || 2000,
            speedup: Number(document.getElementById("speedup")?.value) || 4,
            startBearing:
              Number(document.getElementById("startBearing").value) || 0,
            startAltitude:
              Number(document.getElementById("startAltitude").value) || 500000,
            pitch: Number(document.getElementById("pitch").value) || 20,
            lineGradient: document.getElementById("lineGradient").checked,
            cameraFollow: document.getElementById("cameraFollow").checked,
            bearingChange: document.getElementById("bearingChange").checked,
            exportMode: true,
            onProgress: (p) => {
              statusEl.textContent =
                "Exporting... " + Math.round(p * 100) + "%";
            },
            onRender: captureFrame,
          });
          const mp4 = encoder.end();

          const a = document.createElement("a");
          a.href = URL.createObjectURL(new Blob([mp4], { type: "video/mp4" }));
          a.download = "route-animation.mp4";
          a.click();
          URL.revokeObjectURL(a.href);

          statusEl.textContent =
            "Done. Run ffmpeg -i route-animation.mp4 out.mp4 to compress.";
        } catch (err) {
          statusEl.textContent = "Error: " + (err.message || "Export failed");
        } finally {
          mapEl.style.width = savedWidth;
          mapEl.style.height = savedHeight;
          map.resize();
          exportBtn.disabled = false;
          setPanelOpen(true);
        }
      }
    </script>
  </body>
</html>
